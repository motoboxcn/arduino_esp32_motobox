# ESP32-S3 MotoBox 低功耗设计

## 概述

本文档详细说明ESP32-S3 MotoBox项目的低功耗设计实现，包括硬件优化、软件策略和传感器管理。

## 低功耗架构

### 1. 电源状态管理

```cpp
enum PowerState {
    POWER_STATE_NORMAL,           // 正常工作状态
    POWER_STATE_PREPARING_SLEEP   // 正在准备进入睡眠状态
};
```

### 2. 核心策略

- **运动检测触发**: 基于IMU运动检测的智能休眠
- **车辆状态优化**: 车辆启动时跳过IMU检测，节省CPU资源
- **分层外设管理**: 按功耗优先级关闭外设
- **多唤醒源支持**: IMU运动唤醒 + 定时器备用唤醒

## 外设功耗管理

### 高功耗外设（优先关闭）

#### 1. Air780EG 4G模块
```cpp
// 最大功耗外设，优先关闭
air780eg.powerOff();
```
- **工作功耗**: ~200-500mA
- **关闭策略**: 3秒超时保护，避免长时间等待

#### 2. WiFi 和蓝牙
```cpp
// WiFi完全关闭
WiFi.disconnect(true);
WiFi.mode(WIFI_OFF);
esp_wifi_deinit();

// 蓝牙完全关闭
btStop();
esp_bt_controller_disable();
esp_bt_controller_deinit();
```
- **WiFi功耗**: ~80-200mA
- **蓝牙功耗**: ~20-50mA

#### 3. SD卡存储
```cpp
// SD卡低功耗配置
void disableSDCard() {
    SD.end();                    // 卸载文件系统
    SPI.end();                   // 关闭SPI总线
    // 配置GPIO为低功耗模式
}
```
- **工作功耗**: ~10-30mA
- **优化效果**: 降至μA级别

### 中等功耗外设

#### 4. LED 和 PWM
```cpp
pwmLed.setBrightness(0);
pwmLed.deinit();
```

#### 5. TFT 显示屏
```cpp
// 关闭显示屏背光和电源
// 需要根据具体驱动实现
```

#### 6. 音频模块
```cpp
// 关闭音频放大器
audioManager.powerOff();
```

## 传感器低功耗管理

### IMU传感器（QMI8658）✅ 完全支持

#### 功耗模式设置
```cpp
void setAccelPowerMode(uint8_t mode) {
    switch (mode) {
        case 0: // 低功耗模式 - 125Hz
        case 1: // 正常模式 - 500Hz  
        case 2: // 高性能模式 - 1000Hz
    }
}
```

#### 深度睡眠配置
```cpp
bool configureForDeepSleep() {
    // WakeOnMotion配置
    qmi.configWakeOnMotion(
        255,                                   // 255mg阈值
        SensorQMI8658::ACC_ODR_LOWPOWER_128Hz, // 低功耗128Hz
        SensorQMI8658::INTERRUPT_PIN_1,        // 中断引脚1
        1,                                     // 默认引脚值
        0x30                                   // 抑制时间
    );
}
```

#### 陀螺仪控制
```cpp
void setGyroEnabled(bool enabled) {
    // 可完全关闭陀螺仪节省功耗
}
```

### 罗盘传感器（QMC5883L）✅ 新增支持

#### 低功耗模式
```cpp
void enterLowPowerMode() {
    // 进入待机模式
    wire.beginTransmission(0x0D);
    wire.write(0x09); // 控制寄存器1
    wire.write(0x00); // 待机模式
    wire.endTransmission();
}
```

#### 深度睡眠配置
```cpp
bool configureForDeepSleep() {
    enterLowPowerMode();
    return true;
}
```

#### 唤醒后恢复
```cpp
void exitLowPowerMode() {
    qmc.init();
    delay(50); // 等待传感器稳定
}
```

## 唤醒源配置

### 1. IMU运动唤醒（主要）
```cpp
// EXT0唤醒配置
esp_sleep_enable_ext0_wakeup((gpio_num_t)IMU_INT_PIN, 0);

// RTC GPIO配置
rtc_gpio_init((gpio_num_t)IMU_INT_PIN);
rtc_gpio_set_direction((gpio_num_t)IMU_INT_PIN, RTC_GPIO_MODE_INPUT_ONLY);
rtc_gpio_pullup_en((gpio_num_t)IMU_INT_PIN);
```

### 2. 定时器唤醒（备用）
```cpp
// 1小时备用唤醒
const uint64_t BACKUP_WAKEUP_TIME = 60 * 60 * 1000000ULL;
esp_sleep_enable_timer_wakeup(BACKUP_WAKEUP_TIME);
```

### 3. 车辆启动检测（可选）
```cpp
#ifdef RTC_INT_PIN
bool isVehicleStarted() {
    return (digitalRead(RTC_INT_PIN) == LOW);
}
#endif
```

## GPIO低功耗配置

### 未使用GPIO配置
```cpp
void configureGPIOForSleep() {
    const int unused_gpios[] = {0, 2, 4, 5, 12, 13, 14, 15, 17, 18, 19, 27, 32, 35};
    
    for (int gpio : unused_gpios) {
        // 跳过正在使用的引脚
        if (gpio == IMU_INT_PIN || gpio == RTC_INT_PIN) continue;
        
        // 配置为输入，禁用上下拉
        gpio_config_t io_conf = {};
        io_conf.intr_type = GPIO_INTR_DISABLE;
        io_conf.mode = GPIO_MODE_INPUT;
        io_conf.pin_bit_mask = (1ULL << gpio);
        io_conf.pull_down_en = GPIO_PULLDOWN_DISABLE;
        io_conf.pull_up_en = GPIO_PULLUP_DISABLE;
        gpio_config(&io_conf);
    }
}
```

## 电源域配置

### 深度睡眠电源域优化
```cpp
void configurePowerDomains() {
    esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_PERIPH, ESP_PD_OPTION_ON);
    esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_SLOW_MEM, ESP_PD_OPTION_ON);
    esp_sleep_pd_config(ESP_PD_DOMAIN_RTC_FAST_MEM, ESP_PD_OPTION_OFF);
    esp_sleep_pd_config(ESP_PD_DOMAIN_XTAL, ESP_PD_OPTION_OFF);
    esp_sleep_pd_config(ESP_PD_DOMAIN_VDDSDIO, ESP_PD_OPTION_OFF);
}
```

## 功耗测试与优化

### 预期功耗水平

| 状态 | 功耗 | 说明 |
|------|------|------|
| 正常工作 | 200-500mA | 4G模块工作时 |
| WiFi工作 | 80-200mA | WiFi连接时 |
| 传感器工作 | 10-50mA | 仅传感器工作 |
| 深度睡眠 | 10-100μA | 理想低功耗状态 |

### 优化效果

1. **Air780EG关闭**: 节省200-500mA
2. **WiFi/蓝牙关闭**: 节省80-200mA
3. **SD卡优化**: 节省10-30mA
4. **传感器低功耗**: 节省5-20mA
5. **GPIO优化**: 节省1-5mA

## 使用方法

### 1. 设置休眠时间
```cpp
powerManager.setSleepTime(300); // 5分钟
```

### 2. 手动进入低功耗
```cpp
powerManager.enterLowPowerMode();
```

### 3. 测试休眠功能
```cpp
powerManager.testSafeEnterSleep(); // 10秒后自动唤醒
```

### 4. 传感器功耗控制
```cpp
// IMU低功耗模式
imu.setAccelPowerMode(0); // 低功耗
imu.setGyroEnabled(false); // 关闭陀螺仪

// 罗盘低功耗模式
compass.enterLowPowerMode();
```

## 调试与监控

### 唤醒原因检查
```cpp
void printWakeupReason() {
    esp_sleep_wakeup_cause_t wakeup_reason = esp_sleep_get_wakeup_cause();
    switch (wakeup_reason) {
        case ESP_SLEEP_WAKEUP_EXT0:
            Serial.println("IMU运动唤醒");
            break;
        case ESP_SLEEP_WAKEUP_TIMER:
            Serial.println("定时器唤醒");
            break;
    }
}
```

### 功耗监控日志
```
[电源管理] 关闭 Air780EG 模块...
[电源管理] ✅ Air780EG 模块已关闭
[电源管理] 关闭 WiFi 和蓝牙...
[电源管理] ✅ WiFi 完全关闭
[电源管理] ✅ 蓝牙完全关闭
[电源管理] 配置传感器低功耗模式...
[电源管理] ✅ 罗盘传感器已配置低功耗模式
[电源管理] 💤 进入深度睡眠
```

## 注意事项

### 1. 看门狗管理
- 在长时间操作中定期调用`esp_task_wdt_reset()`
- 避免在外设关闭过程中触发看门狗重启

### 2. 传感器恢复
- 唤醒后需要适当延时等待传感器稳定
- IMU需要500ms，罗盘需要50ms

### 3. 兼容性
- 支持编译时禁用休眠功能（`#ifndef ENABLE_SLEEP`）
- 向后兼容没有RTC_INT_PIN的环境

### 4. 安全性
- 提供安全的休眠测试功能
- 多重检查避免意外进入不可恢复状态

## 总结

ESP32-S3 MotoBox的低功耗设计通过分层的外设管理、智能的传感器控制和完善的唤醒机制，实现了从正常工作的数百毫安到深度睡眠的微安级功耗转换，大大延长了设备的电池续航时间。
